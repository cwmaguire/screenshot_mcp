"""
Screenshot utilities for MCP Screenshot Server.
"""

import asyncio
import logging
import os
import tempfile
import shutil
from contextlib import asynccontextmanager
from typing import AsyncGenerator, Optional, List, Dict, Any
from pathlib import Path

from openai import AsyncOpenAI


import subprocess
import threading

async def take_screenshot(output_path: str) -> bool:
    """Take a screenshot of the active window using scrot.

    Args:
        output_path: Path to save the screenshot

    Returns:
        True if successful, False otherwise
    """
    from config import config  # Import here to avoid circular imports

    logging.info(f"take_screenshot called with output_path: {output_path}")

    def run_capture():
        try:
            # Ensure the directory exists
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            # Get active window ID
            id_result = subprocess.run(
                ["xdotool", "getactivewindow"],
                env=os.environ,
                capture_output=True,
                text=True,
                timeout=5.0
            )
            if id_result.returncode != 0:
                return -3, "", f"Failed to get active window ID: {id_result.stderr}"
            window_id = id_result.stdout.strip()

            # Run import for active window capture
            result = subprocess.run(
                ["import", "-window", window_id, output_path],
                env=os.environ,
                capture_output=True,
                text=True,
                timeout=config.SUBPROCESS_TIMEOUT
            )
            return result.returncode, result.stdout, result.stderr
        except subprocess.TimeoutExpired:
            return -1, "", "Timeout"
        except Exception as e:
            return -2, "", str(e)

    try:
        returncode, stdout, stderr = await asyncio.to_thread(run_capture)
        logging.info(f"import returncode: {returncode}")
        if returncode != 0:
            logging.error(f"import failed with return code {returncode}: {stderr}")
        success = returncode == 0 and os.path.exists(output_path) and os.path.getsize(output_path) > 0
        logging.info(f"import success: {success}, file exists: {os.path.exists(output_path)}, size: {os.path.getsize(output_path) if os.path.exists(output_path) else 0}")
        return success
    except Exception as e:
        logging.error(f"Exception in take_screenshot: {e}")
        return False


async def extract_text_from_image(image_path: str) -> Optional[str]:
    """Extract text from an image using OCR.

    Args:
        image_path: Path to the image file

    Returns:
        Extracted text or None if failed
    """
    from config import config  # Import here to avoid circular imports

    try:
        import pytesseract
        from PIL import Image

        # Run OCR in a thread pool with timeout
        def ocr_task():
            with Image.open(image_path) as img:
                return pytesseract.image_to_string(img)

        text = await asyncio.wait_for(
            asyncio.get_event_loop().run_in_executor(None, ocr_task),
            timeout=config.OCR_TIMEOUT
        )

        return text.strip() if text else None
    except asyncio.TimeoutError:
        return None
    except Exception:
        return None


async def analyze_screenshot_with_grok(image_path: str, mode: str = "description", question: Optional[str] = None) -> Optional[str]:
    """Analyze screenshot with Grok-4 AI.

    Args:
        image_path: Path to screenshot
        mode: Analysis mode ("description", "question", "both")
        question: Specific question if mode is "question" or "both"

    Returns:
        Analysis result or None
    """
    from config import config  # Import here to avoid circular imports

    try:
        # Read the image as base64
        import base64
        with open(image_path, "rb") as img_file:
            image_data = base64.b64encode(img_file.read()).decode('utf-8')

        description_prompt = """
        You are an expert UI analyst specializing in text-based user interfaces (TUIs) from terminal screenshots. Analyze the provided screenshot of an LLM CLI TUI (a command-line interface tool built in Python, rendered in a terminal window). The image has been cropped to focus only on the TUI content, excluding any surrounding terminal borders or evidence of the environment to ensure it's viewed as a standard software interface.
Your task is to generate a detailed, structured textual description of the TUI's UI elements. This description will be fed back to an AI code generator ('grok-code-fast-1') that can't see images, so it must be precise, comprehensive, and text-only to help verify and iterate on the design.
Structure your response exactly as follows:

Overall Summary: A 1-2 paragraph high-level overview of the TUI's purpose and layout (e.g., "This appears to be a chat-like CLI with a command input at the bottom and output history above").
Dimensions and Grid: Estimate the visible grid size (rows x columns, e.g., "Approximately 24 rows by 80 columns"). Describe major sections and their positions/sizes (e.g., "Header: rows 1-3, full width; Main content: rows 4-20, left 30% sidebar + right 70% panel").
Borders and Dividers: List all borders, their types (e.g., single-line ASCII '─│┌┐', double-line, or none), styles (e.g., bold, colored), and locations (e.g., "Vertical divider at column 25 separating sidebar from main area").
Colors and Styling: Describe color schemes (e.g., "Default text: white on black; Commands: green foreground; Errors: red bold"). Note background/foreground for key elements, and any highlights, underlines, or inversions.
Text Content and Layout Details:
Break down by section (e.g., Header, Sidebar, Main Output, Input Area).
For each: Quote or paraphrase key text, count lines/items (e.g., "Main output: 12 lines of wrapped text, left-aligned").
Note alignments, lists/tables, special characters, or ASCII art.

Interactive Elements: Identify inputs, menus, buttons, cursors (e.g., "Blinking cursor in bottom input field; Selectable menu items highlighted in blue").
Potential Issues or Anomalies: Any rendering problems (e.g., "Text overflows border at row 15; Misaligned column in table").
Pseudo-ASCII Recreation: Provide a simplified ASCII art representation of the layout (e.g., using boxes and labels) to visualize the structure, limited to 20-30 lines.

Focus only on UI elements relevant to the TUI design—ignore any non-relevant artifacts. Be objective, detailed, and use coordinates (row/column) where possible. Reference terminal standards like ANSI colors if applicable.
Image to analyze:
"""

        question_prompt = """
You are an expert UI analyst specializing in text-based user interfaces
(TUIs) from terminal screenshots. Analyze the provided screenshot of an
LLM CLI TUI (a command-line interface tool built in Python).

Your task is to answer the following question about the TUI's appearance and UI
elements: "{question}". Provide a detailed, structured textual response that
focuses on visual and layout aspects relevant to the question. This response
will be fed back to an AI code generator ('grok-code-fast-1') that can't see
images, so it must be precise, comprehensive, and text-only to help verify and
iterate on the design.

Structure your response exactly as follows, adapting the content to directly
address the question while incorporating relevant details about the TUI:

Overall Summary: A 1-2 paragraph high-level overview of the TUI's layout and
how it relates to the question (e.g., "In response to the question about the
header, this TUI features a prominent top bar...").

Dimensions and Grid: Estimate the visible grid size (rows x columns) and
describe sections relevant to the question, including their positions/sizes.

Borders and Dividers: Detail borders/dividers relevant to the question,
including types, styles, and locations.

Colors and Styling: Describe colors/styling relevant to the question (e.g.,
foreground/background, highlights).

Text Content and Layout Details: Break down text and layout elements relevant
to the question by section, quoting/paraphrasing text, line counts, alignments,
etc.

Interactive Elements: Identify any interactive parts relevant to the question
(e.g., inputs, menus, cursors).

Potential Issues or Anomalies: Note any rendering problems related to the question.

Pseudo-ASCII Recreation: If relevant to the question, provide a simplified
ASCII art representation of the affected layout (limited to 20-30 lines).

Focus only on UI elements relevant to the TUI design and the question—ignore
any non-relevant artifacts. Be objective, detailed, and use coordinates
(row/column) where possible. Reference terminal standards like ANSI colors if
applicable.

Image to analyze:
        """

        messages = [
            {
                "role": "user",
                "content": [
                    {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{image_data}"}},
                    {"type": "text", "text": f"Analyze this screenshot in {mode} mode{' with question: ' + question if question else ''}."}
                ]
            }
        ]

        return await asyncio.wait_for(
            generate_message_with_grok(messages, max_tokens=10000),
            timeout=config.API_TIMEOUT
        )
    except asyncio.TimeoutError:
        return "Analysis timed out."
    except Exception as e:
        return f"Analysis failed: {str(e)}"


async def generate_message_with_grok(messages: List[Dict[str, Any]], max_tokens: int = 10000) -> Optional[str]:
    """Generate a message using Grok-4 AI.

    Args:
        messages: List of message dicts with role and content
        max_tokens: Maximum tokens for response

    Returns:
        Generated message text or None
    """
    try:
        api_key = os.getenv("XAI_API_KEY")
        if not api_key:
            # Fallback to simulation
            last_message = messages[-1] if messages else {}
            content = last_message.get("content", "")
            if isinstance(content, list) and content:
                text = content[0].get("text", "") if isinstance(content[0], dict) else str(content[0])
            else:
                text = str(content)
            return f"Simulated Grok response to: {text[:100]}..."

        client = AsyncOpenAI(
            api_key=api_key,
            base_url="https://api.x.ai/v1"
        )

        response = await asyncio.wait_for(
            client.chat.completions.create(
                model="grok-4",  # Use Grok-4 model
                messages=messages,
                max_tokens=max_tokens,
                temperature=0.7
            ),
            timeout=30.0
        )

        if response.choices and response.choices[0].message:
            return response.choices[0].message.content

        return None
    except asyncio.TimeoutError:
        return "Grok API timeout."
    except Exception as e:
        return f"Grok API error: {str(e)}"


def validate_uri(uri: str) -> bool:
    """Validate a file URI.

    Args:
        uri: URI to validate

    Returns:
        True if valid file URI, False otherwise
    """
    if not uri.startswith("file://"):
        return False

    # Basic path validation
    path = uri[7:]  # Remove 'file://'
    if ".." in path or not path:
        return False

    # Check if path is absolute and within allowed directories
    abs_path = os.path.abspath(path)
    allowed_dirs = ["/tmp", "/home", "/var/tmp"]  # Add more as needed

    return any(abs_path.startswith(allowed_dir) for allowed_dir in allowed_dirs)


def get_file_content(uri: str) -> Optional[bytes]:
    """Get content of a file URI.

    Args:
        uri: File URI

    Returns:
        File content as bytes or None
    """
    if validate_uri(uri):
        abs_path = os.path.abspath(uri[7:])
        try:
            with open(abs_path, 'rb') as f:
                return f.read()
        except Exception:
            pass
    return None
